#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#pragma shader_stage(raygen)

#include "utils.glsl"

layout(location = 0) rayPayloadNV RayPayload Ray;
layout(location = 1) rayPayloadNV ShadowRayPayload ShadowRay;

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;

layout(binding = 1, std140) buffer PixelBuffer {
  vec4 pixels[];
} pixelBuffer;

layout (binding = 2) uniform Camera {
  vec4 forward;
  mat4 viewInverse;
  mat4 projectionInverse;
  mat4 viewProjection;
  mat4 previousViewInverse;
  mat4 previousProjectionInverse;
  uint sampleCount;
  uint totalSampleCount;
} uCamera;

layout(binding = 3, std140) buffer AccumulationBuffer {
  vec4 pixels[];
} accumulationBuffer;

layout(binding = 4, std430) readonly buffer GeometryBuffer {
  Vertex Vertices[];
};

layout(binding = 5, std430) readonly buffer FacesBuffer {
  uint Faces[];
};

layout(binding = 6, std140, row_major) readonly buffer InstanceBuffer {
  Instance Instances[];
};

layout(binding = 7, std430) readonly buffer MaterialBuffer {
  Material Materials[];
};

layout(binding = 8, std430) readonly buffer LightBuffer {
  Light Lights[];
};

const float aperture = 0.0875;
const float focusDistance = 22.0;

const uint lightCount = 1;

LightSource PickRandomLightSource(inout uint seed, in vec3 surfacePos, out vec3 lightDirection, out float lightDistance) {
  const uint lightIndex = 1 + uint(Randf01(seed) * lightCount);
  const uint geometryInstanceId = Lights[nonuniformEXT(lightIndex)].instanceIndex;
  const Instance instance = Instances[nonuniformEXT(geometryInstanceId)];

  const uint faceIndex = instance.faceIndex + uint(Randf01(seed) * instance.faceCount);

  const vec2 attribs = SampleTriangle(vec2(Randf01(seed), Randf01(seed)));

  const Vertex v0 = Vertices[instance.vertexIndex + Faces[faceIndex + 0]];
  const Vertex v1 = Vertices[instance.vertexIndex + Faces[faceIndex + 1]];
  const Vertex v2 = Vertices[instance.vertexIndex + Faces[faceIndex + 2]];

  const vec3 p0 = (instance.transformMatrix * vec4(v0.position.xyz, 1.0)).xyz;
  const vec3 p1 = (instance.transformMatrix * vec4(v1.position.xyz, 1.0)).xyz;
  const vec3 p2 = (instance.transformMatrix * vec4(v2.position.xyz, 1.0)).xyz;
  const vec3 pw = blerp(attribs, p0, p1, p2);

  const vec3 n0 = v0.normal.xyz;
  const vec3 n1 = v1.normal.xyz;
  const vec3 n2 = v2.normal.xyz;
  const vec3 nw = normalize(mat3x3(instance.transformMatrix) * blerp(attribs, n0.xyz, n1.xyz, n2.xyz));

  const float triangleArea = 0.5 * length(cross(p1 - p0, p2 - p0));

  const vec3 lightSurfacePos = pw;
  const vec3 lightEmission = Materials[instance.materialIndex].color;
  const vec3 lightNormal = normalize(lightSurfacePos - surfacePos);

  const vec3 lightPos = lightSurfacePos - surfacePos;
  const float lightDist = length(lightPos);
  const float lightDistSq = lightDist * lightDist;
  const vec3 lightDir = lightPos / lightDist;

  const float lightPdf = lightDistSq / (triangleArea * abs(dot(lightNormal, lightDir)));

  const vec4 emissionAndGeometryId = vec4(
    lightEmission, geometryInstanceId
  );
  const vec4 directionAndPdf = vec4(
    lightDir, lightPdf
  );

  lightDirection = lightDir;
  lightDistance = lightDist;

  return LightSource(
    emissionAndGeometryId,
    directionAndPdf
  );
}

void main() {
  const ivec2 ipos = ivec2(gl_LaunchIDNV.xy);
  const ivec2 resolution = ivec2(gl_LaunchSizeNV.xy);
  const uint pixelIndex = ipos.y * resolution.x + ipos.x;

  const uint sampleCount = uCamera.sampleCount;
  const uint bounceCount = 4;
  const uint totalSampleCount = uCamera.totalSampleCount;

  Ray.seed = Tea(Tea(ipos.x, ipos.y), uCamera.totalSampleCount);

  const float tMin = 0.01;
  const float tMax = 8192.0;

  const uint cullMask = 0x80; // -> GeometryLayout.mask

  // in case camera UBO isn't staged
  const mat4 mViewInverse = uCamera.viewInverse;
  const mat4 mProjectionInverse = uCamera.projectionInverse;

  vec3 pixelColor = vec3(0);
  for (uint ss = 0; ss < sampleCount; ++ss) {
    const vec2 offset = aperture / 2.0 * RandInUnitDisk(Ray.seed);
    const vec2 pixel = vec2(ipos.x + Randf01(Ray.seed), ipos.y + Randf01(Ray.seed));
    const vec2 uv = (pixel / gl_LaunchSizeNV.xy) * 2.0 - 1.0;

    vec4 origin = mViewInverse * vec4(offset, 0, 1);
    vec4 target = mProjectionInverse * (vec4(uv.x, uv.y, 1, 1));
    vec4 direction = mViewInverse * vec4(normalize(target.xyz * focusDistance - vec3(offset, 0)), 0);

    vec3 radiance = vec3(0);
    Ray.throughput = vec4(1);
    for (uint bb = 0; bb < bounceCount; ++bb) {
      // shoot initial ray
      // this ray returns us the initial closest-hit position on a surface
      traceNV(topLevelAS, gl_RayFlagsOpaqueNV, cullMask, 1, 1, 1, origin.xyz, tMin, direction.xyz, tMax, 1);
      vec3 surfacePosition = ShadowRay.hit;
      // ray missed everything
      //bool initialMiss = ShadowRay.shadowed;

      // pick a random light source
      // also returns a direction which we will shoot our shadow ray to
      vec3 lightDirection = vec3(0);
      float lightDistance = 0.0;
      LightSource lightSource = PickRandomLightSource(Ray.seed, surfacePosition, lightDirection, lightDistance);
      Ray.lightSource = lightSource;

      // shoot the shadow ray
      traceNV(topLevelAS, gl_RayFlagsTerminateOnFirstHitNV, 0xFF, 1, 1, 1, surfacePosition, EPSILON, lightDirection, lightDistance - EPSILON, 1);
      Ray.shadowed = ShadowRay.shadowed;

      // execute the shading
      // use callable shader for this?
      traceNV(topLevelAS, gl_RayFlagsOpaqueNV, cullMask, 0, 0, 0, origin.xyz, tMin, direction.xyz, tMax, 0);

      radiance += Ray.radianceAndDistance.rgb;

      // abort if the ray is either invalid or didn't hit anything
      const float t = Ray.radianceAndDistance.w;
      if (t < 0.0 || Ray.scatterDirection.w <= 0.0) break;

      // move the ray based on the bsdf direction
      origin = origin + t * direction;
      direction = vec4(Ray.scatterDirection.xyz, 0);
    };
    pixelColor += radiance;
  };
  pixelColor = max(vec3(0), pixelColor);

  const bool accumulate = uCamera.sampleCount != uCamera.totalSampleCount;
  const vec3 accumulatedColor = accumulationBuffer.pixels[pixelIndex].rgb * float(accumulate) + pixelColor;
  pixelColor = accumulatedColor * (1.0 / uCamera.totalSampleCount);
  accumulationBuffer.pixels[pixelIndex].rgb = accumulatedColor;

  pixelColor = Uncharted2ToneMapping(pixelColor * (1.0 / uCamera.sampleCount));

  pixelBuffer.pixels[pixelIndex] = vec4(pow(pixelColor, vec3(1.0 / 2.2)), 1);
}
